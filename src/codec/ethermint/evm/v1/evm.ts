/* eslint-disable */
import Long from "long";
import _m0 from "protobufjs/minimal";

export const protobufPackage = "ethermint.evm.v1";

/** Params defines the EVM module parameters */
export interface Params {
  /**
   * evm_denom represents the token denomination used to run the EVM state
   * transitions.
   */
  evmDenom: string;
  /** enable_create toggles state transitions that use the vm.Create function */
  enableCreate: boolean;
  /** enable_call toggles state transitions that use the vm.Call function */
  enableCall: boolean;
  /** extra_eips defines the additional EIPs for the vm.Config */
  extraEips: Long[];
  /** chain_config defines the EVM chain configuration parameters */
  chainConfig?: ChainConfig;
  /**
   * allow_unprotected_txs defines if replay-protected (i.e non EIP155
   * signed) transactions can be executed on the state machine.
   */
  allowUnprotectedTxs: boolean;
}

/**
 * ChainConfig defines the Ethereum ChainConfig parameters using *sdk.Int values
 * instead of *big.Int.
 */
export interface ChainConfig {
  /** homestead_block switch (nil no fork, 0 = already homestead) */
  homesteadBlock: string;
  /** dao_fork_block corresponds to TheDAO hard-fork switch block (nil no fork) */
  daoForkBlock: string;
  /** dao_fork_support defines whether the nodes supports or opposes the DAO hard-fork */
  daoForkSupport: boolean;
  /**
   * eip150_block: EIP150 implements the Gas price changes
   * (https://github.com/ethereum/EIPs/issues/150) EIP150 HF block (nil no fork)
   */
  eip150Block: string;
  /** eip150_hash: EIP150 HF hash (needed for header only clients as only gas pricing changed) */
  eip150Hash: string;
  /** eip155_block: EIP155Block HF block */
  eip155Block: string;
  /** eip158_block: EIP158 HF block */
  eip158Block: string;
  /** byzantium_block: Byzantium switch block (nil no fork, 0 = already on byzantium) */
  byzantiumBlock: string;
  /** constantinople_block: Constantinople switch block (nil no fork, 0 = already activated) */
  constantinopleBlock: string;
  /** petersburg_block: Petersburg switch block (nil same as Constantinople) */
  petersburgBlock: string;
  /** istanbul_block: Istanbul switch block (nil no fork, 0 = already on istanbul) */
  istanbulBlock: string;
  /** muir_glacier_block: Eip-2384 (bomb delay) switch block (nil no fork, 0 = already activated) */
  muirGlacierBlock: string;
  /** berlin_block: Berlin switch block (nil = no fork, 0 = already on berlin) */
  berlinBlock: string;
  /** london_block: London switch block (nil = no fork, 0 = already on london) */
  londonBlock: string;
  /** arrow_glacier_block: Eip-4345 (bomb delay) switch block (nil = no fork, 0 = already activated) */
  arrowGlacierBlock: string;
  /** gray_glacier_block: EIP-5133 (bomb delay) switch block (nil = no fork, 0 = already activated) */
  grayGlacierBlock: string;
  /** merge_netsplit_block: Virtual fork after The Merge to use as a network splitter */
  mergeNetsplitBlock: string;
  /** shanghai_block switch block (nil = no fork, 0 = already on shanghai) */
  shanghaiBlock: string;
  /** cancun_block switch block (nil = no fork, 0 = already on cancun) */
  cancunBlock: string;
}

/** State represents a single Storage key value pair item. */
export interface State {
  /** key is the stored key */
  key: string;
  /** value is the stored value for the given key */
  value: string;
}

/**
 * TransactionLogs define the logs generated from a transaction execution
 * with a given hash. It it used for import/export data as transactions are not
 * persisted on blockchain state after an upgrade.
 */
export interface TransactionLogs {
  /** hash of the transaction */
  hash: string;
  /** logs is an array of Logs for the given transaction hash */
  logs: Log[];
}

/**
 * Log represents an protobuf compatible Ethereum Log that defines a contract
 * log event. These events are generated by the LOG opcode and stored/indexed by
 * the node.
 *
 * NOTE: address, topics and data are consensus fields. The rest of the fields
 * are derived, i.e. filled in by the nodes, but not secured by consensus.
 */
export interface Log {
  /** address of the contract that generated the event */
  address: string;
  /** topics is a list of topics provided by the contract. */
  topics: string[];
  /** data which is supplied by the contract, usually ABI-encoded */
  data: Uint8Array;
  /** block_number of the block in which the transaction was included */
  blockNumber: Long;
  /** tx_hash is the transaction hash */
  txHash: string;
  /** tx_index of the transaction in the block */
  txIndex: Long;
  /** block_hash of the block in which the transaction was included */
  blockHash: string;
  /** index of the log in the block */
  index: Long;
  /**
   * removed is true if this log was reverted due to a chain
   * reorganisation. You must pay attention to this field if you receive logs
   * through a filter query.
   */
  removed: boolean;
}

/** TxResult stores results of Tx execution. */
export interface TxResult {
  /**
   * contract_address contains the ethereum address of the created contract (if
   * any). If the state transition is an evm.Call, the contract address will be
   * empty.
   */
  contractAddress: string;
  /** bloom represents the bloom filter bytes */
  bloom: Uint8Array;
  /**
   * tx_logs contains the transaction hash and the proto-compatible ethereum
   * logs.
   */
  txLogs?: TransactionLogs;
  /** ret defines the bytes from the execution. */
  ret: Uint8Array;
  /** reverted flag is set to true when the call has been reverted */
  reverted: boolean;
  /** gas_used notes the amount of gas consumed while execution */
  gasUsed: Long;
}

/** AccessTuple is the element type of an access list. */
export interface AccessTuple {
  /** address is a hex formatted ethereum address */
  address: string;
  /** storage_keys are hex formatted hashes of the storage keys */
  storageKeys: string[];
}

/** TraceConfig holds extra parameters to trace functions. */
export interface TraceConfig {
  /** tracer is a custom javascript tracer */
  tracer: string;
  /**
   * timeout overrides the default timeout of 5 seconds for JavaScript-based tracing
   * calls
   */
  timeout: string;
  /** reexec defines the number of blocks the tracer is willing to go back */
  reexec: Long;
  /** disable_stack switches stack capture */
  disableStack: boolean;
  /** disable_storage switches storage capture */
  disableStorage: boolean;
  /** debug can be used to print output during capture end */
  debug: boolean;
  /** limit defines the maximum length of output, but zero means unlimited */
  limit: number;
  /** overrides can be used to execute a trace using future fork rules */
  overrides?: ChainConfig;
  /** enable_memory switches memory capture */
  enableMemory: boolean;
  /** enable_return_data switches the capture of return data */
  enableReturnData: boolean;
  /** tracer_json_config configures the tracer using a JSON string */
  tracerJsonConfig: string;
}

const baseParams: object = {
  evmDenom: "",
  enableCreate: false,
  enableCall: false,
  extraEips: Long.ZERO,
  allowUnprotectedTxs: false,
};

export const Params = {
  encode(
    message: Params,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.evmDenom !== "") {
      writer.uint32(10).string(message.evmDenom);
    }
    if (message.enableCreate === true) {
      writer.uint32(16).bool(message.enableCreate);
    }
    if (message.enableCall === true) {
      writer.uint32(24).bool(message.enableCall);
    }
    writer.uint32(34).fork();
    for (const v of message.extraEips) {
      writer.int64(v);
    }
    writer.ldelim();
    if (message.chainConfig !== undefined) {
      ChainConfig.encode(
        message.chainConfig,
        writer.uint32(42).fork()
      ).ldelim();
    }
    if (message.allowUnprotectedTxs === true) {
      writer.uint32(48).bool(message.allowUnprotectedTxs);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Params {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...baseParams } as Params;
    message.extraEips = [];
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.evmDenom = reader.string();
          break;
        case 2:
          message.enableCreate = reader.bool();
          break;
        case 3:
          message.enableCall = reader.bool();
          break;
        case 4:
          if ((tag & 7) === 2) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.extraEips.push(reader.int64() as Long);
            }
          } else {
            message.extraEips.push(reader.int64() as Long);
          }
          break;
        case 5:
          message.chainConfig = ChainConfig.decode(reader, reader.uint32());
          break;
        case 6:
          message.allowUnprotectedTxs = reader.bool();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): Params {
    const message = { ...baseParams } as Params;
    message.evmDenom =
      object.evmDenom !== undefined && object.evmDenom !== null
        ? String(object.evmDenom)
        : "";
    message.enableCreate =
      object.enableCreate !== undefined && object.enableCreate !== null
        ? Boolean(object.enableCreate)
        : false;
    message.enableCall =
      object.enableCall !== undefined && object.enableCall !== null
        ? Boolean(object.enableCall)
        : false;
    message.extraEips = (object.extraEips ?? []).map((e: any) =>
      Long.fromString(e)
    );
    message.chainConfig =
      object.chainConfig !== undefined && object.chainConfig !== null
        ? ChainConfig.fromJSON(object.chainConfig)
        : undefined;
    message.allowUnprotectedTxs =
      object.allowUnprotectedTxs !== undefined &&
      object.allowUnprotectedTxs !== null
        ? Boolean(object.allowUnprotectedTxs)
        : false;
    return message;
  },

  toJSON(message: Params): unknown {
    const obj: any = {};
    message.evmDenom !== undefined && (obj.evmDenom = message.evmDenom);
    message.enableCreate !== undefined &&
      (obj.enableCreate = message.enableCreate);
    message.enableCall !== undefined && (obj.enableCall = message.enableCall);
    if (message.extraEips) {
      obj.extraEips = message.extraEips.map((e) => (e || Long.ZERO).toString());
    } else {
      obj.extraEips = [];
    }
    message.chainConfig !== undefined &&
      (obj.chainConfig = message.chainConfig
        ? ChainConfig.toJSON(message.chainConfig)
        : undefined);
    message.allowUnprotectedTxs !== undefined &&
      (obj.allowUnprotectedTxs = message.allowUnprotectedTxs);
    return obj;
  },

  fromPartial(object: DeepPartial<Params>): Params {
    const message = { ...baseParams } as Params;
    message.evmDenom = object.evmDenom ?? "";
    message.enableCreate = object.enableCreate ?? false;
    message.enableCall = object.enableCall ?? false;
    message.extraEips = (object.extraEips ?? []).map((e) => Long.fromValue(e));
    message.chainConfig =
      object.chainConfig !== undefined && object.chainConfig !== null
        ? ChainConfig.fromPartial(object.chainConfig)
        : undefined;
    message.allowUnprotectedTxs = object.allowUnprotectedTxs ?? false;
    return message;
  },
};

const baseChainConfig: object = {
  homesteadBlock: "",
  daoForkBlock: "",
  daoForkSupport: false,
  eip150Block: "",
  eip150Hash: "",
  eip155Block: "",
  eip158Block: "",
  byzantiumBlock: "",
  constantinopleBlock: "",
  petersburgBlock: "",
  istanbulBlock: "",
  muirGlacierBlock: "",
  berlinBlock: "",
  londonBlock: "",
  arrowGlacierBlock: "",
  grayGlacierBlock: "",
  mergeNetsplitBlock: "",
  shanghaiBlock: "",
  cancunBlock: "",
};

export const ChainConfig = {
  encode(
    message: ChainConfig,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.homesteadBlock !== "") {
      writer.uint32(10).string(message.homesteadBlock);
    }
    if (message.daoForkBlock !== "") {
      writer.uint32(18).string(message.daoForkBlock);
    }
    if (message.daoForkSupport === true) {
      writer.uint32(24).bool(message.daoForkSupport);
    }
    if (message.eip150Block !== "") {
      writer.uint32(34).string(message.eip150Block);
    }
    if (message.eip150Hash !== "") {
      writer.uint32(42).string(message.eip150Hash);
    }
    if (message.eip155Block !== "") {
      writer.uint32(50).string(message.eip155Block);
    }
    if (message.eip158Block !== "") {
      writer.uint32(58).string(message.eip158Block);
    }
    if (message.byzantiumBlock !== "") {
      writer.uint32(66).string(message.byzantiumBlock);
    }
    if (message.constantinopleBlock !== "") {
      writer.uint32(74).string(message.constantinopleBlock);
    }
    if (message.petersburgBlock !== "") {
      writer.uint32(82).string(message.petersburgBlock);
    }
    if (message.istanbulBlock !== "") {
      writer.uint32(90).string(message.istanbulBlock);
    }
    if (message.muirGlacierBlock !== "") {
      writer.uint32(98).string(message.muirGlacierBlock);
    }
    if (message.berlinBlock !== "") {
      writer.uint32(106).string(message.berlinBlock);
    }
    if (message.londonBlock !== "") {
      writer.uint32(138).string(message.londonBlock);
    }
    if (message.arrowGlacierBlock !== "") {
      writer.uint32(146).string(message.arrowGlacierBlock);
    }
    if (message.grayGlacierBlock !== "") {
      writer.uint32(162).string(message.grayGlacierBlock);
    }
    if (message.mergeNetsplitBlock !== "") {
      writer.uint32(170).string(message.mergeNetsplitBlock);
    }
    if (message.shanghaiBlock !== "") {
      writer.uint32(178).string(message.shanghaiBlock);
    }
    if (message.cancunBlock !== "") {
      writer.uint32(186).string(message.cancunBlock);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ChainConfig {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...baseChainConfig } as ChainConfig;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.homesteadBlock = reader.string();
          break;
        case 2:
          message.daoForkBlock = reader.string();
          break;
        case 3:
          message.daoForkSupport = reader.bool();
          break;
        case 4:
          message.eip150Block = reader.string();
          break;
        case 5:
          message.eip150Hash = reader.string();
          break;
        case 6:
          message.eip155Block = reader.string();
          break;
        case 7:
          message.eip158Block = reader.string();
          break;
        case 8:
          message.byzantiumBlock = reader.string();
          break;
        case 9:
          message.constantinopleBlock = reader.string();
          break;
        case 10:
          message.petersburgBlock = reader.string();
          break;
        case 11:
          message.istanbulBlock = reader.string();
          break;
        case 12:
          message.muirGlacierBlock = reader.string();
          break;
        case 13:
          message.berlinBlock = reader.string();
          break;
        case 17:
          message.londonBlock = reader.string();
          break;
        case 18:
          message.arrowGlacierBlock = reader.string();
          break;
        case 20:
          message.grayGlacierBlock = reader.string();
          break;
        case 21:
          message.mergeNetsplitBlock = reader.string();
          break;
        case 22:
          message.shanghaiBlock = reader.string();
          break;
        case 23:
          message.cancunBlock = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): ChainConfig {
    const message = { ...baseChainConfig } as ChainConfig;
    message.homesteadBlock =
      object.homesteadBlock !== undefined && object.homesteadBlock !== null
        ? String(object.homesteadBlock)
        : "";
    message.daoForkBlock =
      object.daoForkBlock !== undefined && object.daoForkBlock !== null
        ? String(object.daoForkBlock)
        : "";
    message.daoForkSupport =
      object.daoForkSupport !== undefined && object.daoForkSupport !== null
        ? Boolean(object.daoForkSupport)
        : false;
    message.eip150Block =
      object.eip150Block !== undefined && object.eip150Block !== null
        ? String(object.eip150Block)
        : "";
    message.eip150Hash =
      object.eip150Hash !== undefined && object.eip150Hash !== null
        ? String(object.eip150Hash)
        : "";
    message.eip155Block =
      object.eip155Block !== undefined && object.eip155Block !== null
        ? String(object.eip155Block)
        : "";
    message.eip158Block =
      object.eip158Block !== undefined && object.eip158Block !== null
        ? String(object.eip158Block)
        : "";
    message.byzantiumBlock =
      object.byzantiumBlock !== undefined && object.byzantiumBlock !== null
        ? String(object.byzantiumBlock)
        : "";
    message.constantinopleBlock =
      object.constantinopleBlock !== undefined &&
      object.constantinopleBlock !== null
        ? String(object.constantinopleBlock)
        : "";
    message.petersburgBlock =
      object.petersburgBlock !== undefined && object.petersburgBlock !== null
        ? String(object.petersburgBlock)
        : "";
    message.istanbulBlock =
      object.istanbulBlock !== undefined && object.istanbulBlock !== null
        ? String(object.istanbulBlock)
        : "";
    message.muirGlacierBlock =
      object.muirGlacierBlock !== undefined && object.muirGlacierBlock !== null
        ? String(object.muirGlacierBlock)
        : "";
    message.berlinBlock =
      object.berlinBlock !== undefined && object.berlinBlock !== null
        ? String(object.berlinBlock)
        : "";
    message.londonBlock =
      object.londonBlock !== undefined && object.londonBlock !== null
        ? String(object.londonBlock)
        : "";
    message.arrowGlacierBlock =
      object.arrowGlacierBlock !== undefined &&
      object.arrowGlacierBlock !== null
        ? String(object.arrowGlacierBlock)
        : "";
    message.grayGlacierBlock =
      object.grayGlacierBlock !== undefined && object.grayGlacierBlock !== null
        ? String(object.grayGlacierBlock)
        : "";
    message.mergeNetsplitBlock =
      object.mergeNetsplitBlock !== undefined &&
      object.mergeNetsplitBlock !== null
        ? String(object.mergeNetsplitBlock)
        : "";
    message.shanghaiBlock =
      object.shanghaiBlock !== undefined && object.shanghaiBlock !== null
        ? String(object.shanghaiBlock)
        : "";
    message.cancunBlock =
      object.cancunBlock !== undefined && object.cancunBlock !== null
        ? String(object.cancunBlock)
        : "";
    return message;
  },

  toJSON(message: ChainConfig): unknown {
    const obj: any = {};
    message.homesteadBlock !== undefined &&
      (obj.homesteadBlock = message.homesteadBlock);
    message.daoForkBlock !== undefined &&
      (obj.daoForkBlock = message.daoForkBlock);
    message.daoForkSupport !== undefined &&
      (obj.daoForkSupport = message.daoForkSupport);
    message.eip150Block !== undefined &&
      (obj.eip150Block = message.eip150Block);
    message.eip150Hash !== undefined && (obj.eip150Hash = message.eip150Hash);
    message.eip155Block !== undefined &&
      (obj.eip155Block = message.eip155Block);
    message.eip158Block !== undefined &&
      (obj.eip158Block = message.eip158Block);
    message.byzantiumBlock !== undefined &&
      (obj.byzantiumBlock = message.byzantiumBlock);
    message.constantinopleBlock !== undefined &&
      (obj.constantinopleBlock = message.constantinopleBlock);
    message.petersburgBlock !== undefined &&
      (obj.petersburgBlock = message.petersburgBlock);
    message.istanbulBlock !== undefined &&
      (obj.istanbulBlock = message.istanbulBlock);
    message.muirGlacierBlock !== undefined &&
      (obj.muirGlacierBlock = message.muirGlacierBlock);
    message.berlinBlock !== undefined &&
      (obj.berlinBlock = message.berlinBlock);
    message.londonBlock !== undefined &&
      (obj.londonBlock = message.londonBlock);
    message.arrowGlacierBlock !== undefined &&
      (obj.arrowGlacierBlock = message.arrowGlacierBlock);
    message.grayGlacierBlock !== undefined &&
      (obj.grayGlacierBlock = message.grayGlacierBlock);
    message.mergeNetsplitBlock !== undefined &&
      (obj.mergeNetsplitBlock = message.mergeNetsplitBlock);
    message.shanghaiBlock !== undefined &&
      (obj.shanghaiBlock = message.shanghaiBlock);
    message.cancunBlock !== undefined &&
      (obj.cancunBlock = message.cancunBlock);
    return obj;
  },

  fromPartial(object: DeepPartial<ChainConfig>): ChainConfig {
    const message = { ...baseChainConfig } as ChainConfig;
    message.homesteadBlock = object.homesteadBlock ?? "";
    message.daoForkBlock = object.daoForkBlock ?? "";
    message.daoForkSupport = object.daoForkSupport ?? false;
    message.eip150Block = object.eip150Block ?? "";
    message.eip150Hash = object.eip150Hash ?? "";
    message.eip155Block = object.eip155Block ?? "";
    message.eip158Block = object.eip158Block ?? "";
    message.byzantiumBlock = object.byzantiumBlock ?? "";
    message.constantinopleBlock = object.constantinopleBlock ?? "";
    message.petersburgBlock = object.petersburgBlock ?? "";
    message.istanbulBlock = object.istanbulBlock ?? "";
    message.muirGlacierBlock = object.muirGlacierBlock ?? "";
    message.berlinBlock = object.berlinBlock ?? "";
    message.londonBlock = object.londonBlock ?? "";
    message.arrowGlacierBlock = object.arrowGlacierBlock ?? "";
    message.grayGlacierBlock = object.grayGlacierBlock ?? "";
    message.mergeNetsplitBlock = object.mergeNetsplitBlock ?? "";
    message.shanghaiBlock = object.shanghaiBlock ?? "";
    message.cancunBlock = object.cancunBlock ?? "";
    return message;
  },
};

const baseState: object = { key: "", value: "" };

export const State = {
  encode(message: State, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): State {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...baseState } as State;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.key = reader.string();
          break;
        case 2:
          message.value = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): State {
    const message = { ...baseState } as State;
    message.key =
      object.key !== undefined && object.key !== null ? String(object.key) : "";
    message.value =
      object.value !== undefined && object.value !== null
        ? String(object.value)
        : "";
    return message;
  },

  toJSON(message: State): unknown {
    const obj: any = {};
    message.key !== undefined && (obj.key = message.key);
    message.value !== undefined && (obj.value = message.value);
    return obj;
  },

  fromPartial(object: DeepPartial<State>): State {
    const message = { ...baseState } as State;
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

const baseTransactionLogs: object = { hash: "" };

export const TransactionLogs = {
  encode(
    message: TransactionLogs,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.hash !== "") {
      writer.uint32(10).string(message.hash);
    }
    for (const v of message.logs) {
      Log.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TransactionLogs {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...baseTransactionLogs } as TransactionLogs;
    message.logs = [];
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.hash = reader.string();
          break;
        case 2:
          message.logs.push(Log.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): TransactionLogs {
    const message = { ...baseTransactionLogs } as TransactionLogs;
    message.hash =
      object.hash !== undefined && object.hash !== null
        ? String(object.hash)
        : "";
    message.logs = (object.logs ?? []).map((e: any) => Log.fromJSON(e));
    return message;
  },

  toJSON(message: TransactionLogs): unknown {
    const obj: any = {};
    message.hash !== undefined && (obj.hash = message.hash);
    if (message.logs) {
      obj.logs = message.logs.map((e) => (e ? Log.toJSON(e) : undefined));
    } else {
      obj.logs = [];
    }
    return obj;
  },

  fromPartial(object: DeepPartial<TransactionLogs>): TransactionLogs {
    const message = { ...baseTransactionLogs } as TransactionLogs;
    message.hash = object.hash ?? "";
    message.logs = (object.logs ?? []).map((e) => Log.fromPartial(e));
    return message;
  },
};

const baseLog: object = {
  address: "",
  topics: "",
  blockNumber: Long.UZERO,
  txHash: "",
  txIndex: Long.UZERO,
  blockHash: "",
  index: Long.UZERO,
  removed: false,
};

export const Log = {
  encode(message: Log, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.address !== "") {
      writer.uint32(10).string(message.address);
    }
    for (const v of message.topics) {
      writer.uint32(18).string(v!);
    }
    if (message.data.length !== 0) {
      writer.uint32(26).bytes(message.data);
    }
    if (!message.blockNumber.isZero()) {
      writer.uint32(32).uint64(message.blockNumber);
    }
    if (message.txHash !== "") {
      writer.uint32(42).string(message.txHash);
    }
    if (!message.txIndex.isZero()) {
      writer.uint32(48).uint64(message.txIndex);
    }
    if (message.blockHash !== "") {
      writer.uint32(58).string(message.blockHash);
    }
    if (!message.index.isZero()) {
      writer.uint32(64).uint64(message.index);
    }
    if (message.removed === true) {
      writer.uint32(72).bool(message.removed);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Log {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...baseLog } as Log;
    message.topics = [];
    message.data = new Uint8Array();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.address = reader.string();
          break;
        case 2:
          message.topics.push(reader.string());
          break;
        case 3:
          message.data = reader.bytes();
          break;
        case 4:
          message.blockNumber = reader.uint64() as Long;
          break;
        case 5:
          message.txHash = reader.string();
          break;
        case 6:
          message.txIndex = reader.uint64() as Long;
          break;
        case 7:
          message.blockHash = reader.string();
          break;
        case 8:
          message.index = reader.uint64() as Long;
          break;
        case 9:
          message.removed = reader.bool();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): Log {
    const message = { ...baseLog } as Log;
    message.address =
      object.address !== undefined && object.address !== null
        ? String(object.address)
        : "";
    message.topics = (object.topics ?? []).map((e: any) => String(e));
    message.data =
      object.data !== undefined && object.data !== null
        ? bytesFromBase64(object.data)
        : new Uint8Array();
    message.blockNumber =
      object.blockNumber !== undefined && object.blockNumber !== null
        ? Long.fromString(object.blockNumber)
        : Long.UZERO;
    message.txHash =
      object.txHash !== undefined && object.txHash !== null
        ? String(object.txHash)
        : "";
    message.txIndex =
      object.txIndex !== undefined && object.txIndex !== null
        ? Long.fromString(object.txIndex)
        : Long.UZERO;
    message.blockHash =
      object.blockHash !== undefined && object.blockHash !== null
        ? String(object.blockHash)
        : "";
    message.index =
      object.index !== undefined && object.index !== null
        ? Long.fromString(object.index)
        : Long.UZERO;
    message.removed =
      object.removed !== undefined && object.removed !== null
        ? Boolean(object.removed)
        : false;
    return message;
  },

  toJSON(message: Log): unknown {
    const obj: any = {};
    message.address !== undefined && (obj.address = message.address);
    if (message.topics) {
      obj.topics = message.topics.map((e) => e);
    } else {
      obj.topics = [];
    }
    message.data !== undefined &&
      (obj.data = base64FromBytes(
        message.data !== undefined ? message.data : new Uint8Array()
      ));
    message.blockNumber !== undefined &&
      (obj.blockNumber = (message.blockNumber || Long.UZERO).toString());
    message.txHash !== undefined && (obj.txHash = message.txHash);
    message.txIndex !== undefined &&
      (obj.txIndex = (message.txIndex || Long.UZERO).toString());
    message.blockHash !== undefined && (obj.blockHash = message.blockHash);
    message.index !== undefined &&
      (obj.index = (message.index || Long.UZERO).toString());
    message.removed !== undefined && (obj.removed = message.removed);
    return obj;
  },

  fromPartial(object: DeepPartial<Log>): Log {
    const message = { ...baseLog } as Log;
    message.address = object.address ?? "";
    message.topics = (object.topics ?? []).map((e) => e);
    message.data = object.data ?? new Uint8Array();
    message.blockNumber =
      object.blockNumber !== undefined && object.blockNumber !== null
        ? Long.fromValue(object.blockNumber)
        : Long.UZERO;
    message.txHash = object.txHash ?? "";
    message.txIndex =
      object.txIndex !== undefined && object.txIndex !== null
        ? Long.fromValue(object.txIndex)
        : Long.UZERO;
    message.blockHash = object.blockHash ?? "";
    message.index =
      object.index !== undefined && object.index !== null
        ? Long.fromValue(object.index)
        : Long.UZERO;
    message.removed = object.removed ?? false;
    return message;
  },
};

const baseTxResult: object = {
  contractAddress: "",
  reverted: false,
  gasUsed: Long.UZERO,
};

export const TxResult = {
  encode(
    message: TxResult,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.contractAddress !== "") {
      writer.uint32(10).string(message.contractAddress);
    }
    if (message.bloom.length !== 0) {
      writer.uint32(18).bytes(message.bloom);
    }
    if (message.txLogs !== undefined) {
      TransactionLogs.encode(message.txLogs, writer.uint32(26).fork()).ldelim();
    }
    if (message.ret.length !== 0) {
      writer.uint32(34).bytes(message.ret);
    }
    if (message.reverted === true) {
      writer.uint32(40).bool(message.reverted);
    }
    if (!message.gasUsed.isZero()) {
      writer.uint32(48).uint64(message.gasUsed);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TxResult {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...baseTxResult } as TxResult;
    message.bloom = new Uint8Array();
    message.ret = new Uint8Array();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.contractAddress = reader.string();
          break;
        case 2:
          message.bloom = reader.bytes();
          break;
        case 3:
          message.txLogs = TransactionLogs.decode(reader, reader.uint32());
          break;
        case 4:
          message.ret = reader.bytes();
          break;
        case 5:
          message.reverted = reader.bool();
          break;
        case 6:
          message.gasUsed = reader.uint64() as Long;
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): TxResult {
    const message = { ...baseTxResult } as TxResult;
    message.contractAddress =
      object.contractAddress !== undefined && object.contractAddress !== null
        ? String(object.contractAddress)
        : "";
    message.bloom =
      object.bloom !== undefined && object.bloom !== null
        ? bytesFromBase64(object.bloom)
        : new Uint8Array();
    message.txLogs =
      object.txLogs !== undefined && object.txLogs !== null
        ? TransactionLogs.fromJSON(object.txLogs)
        : undefined;
    message.ret =
      object.ret !== undefined && object.ret !== null
        ? bytesFromBase64(object.ret)
        : new Uint8Array();
    message.reverted =
      object.reverted !== undefined && object.reverted !== null
        ? Boolean(object.reverted)
        : false;
    message.gasUsed =
      object.gasUsed !== undefined && object.gasUsed !== null
        ? Long.fromString(object.gasUsed)
        : Long.UZERO;
    return message;
  },

  toJSON(message: TxResult): unknown {
    const obj: any = {};
    message.contractAddress !== undefined &&
      (obj.contractAddress = message.contractAddress);
    message.bloom !== undefined &&
      (obj.bloom = base64FromBytes(
        message.bloom !== undefined ? message.bloom : new Uint8Array()
      ));
    message.txLogs !== undefined &&
      (obj.txLogs = message.txLogs
        ? TransactionLogs.toJSON(message.txLogs)
        : undefined);
    message.ret !== undefined &&
      (obj.ret = base64FromBytes(
        message.ret !== undefined ? message.ret : new Uint8Array()
      ));
    message.reverted !== undefined && (obj.reverted = message.reverted);
    message.gasUsed !== undefined &&
      (obj.gasUsed = (message.gasUsed || Long.UZERO).toString());
    return obj;
  },

  fromPartial(object: DeepPartial<TxResult>): TxResult {
    const message = { ...baseTxResult } as TxResult;
    message.contractAddress = object.contractAddress ?? "";
    message.bloom = object.bloom ?? new Uint8Array();
    message.txLogs =
      object.txLogs !== undefined && object.txLogs !== null
        ? TransactionLogs.fromPartial(object.txLogs)
        : undefined;
    message.ret = object.ret ?? new Uint8Array();
    message.reverted = object.reverted ?? false;
    message.gasUsed =
      object.gasUsed !== undefined && object.gasUsed !== null
        ? Long.fromValue(object.gasUsed)
        : Long.UZERO;
    return message;
  },
};

const baseAccessTuple: object = { address: "", storageKeys: "" };

export const AccessTuple = {
  encode(
    message: AccessTuple,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.address !== "") {
      writer.uint32(10).string(message.address);
    }
    for (const v of message.storageKeys) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AccessTuple {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...baseAccessTuple } as AccessTuple;
    message.storageKeys = [];
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.address = reader.string();
          break;
        case 2:
          message.storageKeys.push(reader.string());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): AccessTuple {
    const message = { ...baseAccessTuple } as AccessTuple;
    message.address =
      object.address !== undefined && object.address !== null
        ? String(object.address)
        : "";
    message.storageKeys = (object.storageKeys ?? []).map((e: any) => String(e));
    return message;
  },

  toJSON(message: AccessTuple): unknown {
    const obj: any = {};
    message.address !== undefined && (obj.address = message.address);
    if (message.storageKeys) {
      obj.storageKeys = message.storageKeys.map((e) => e);
    } else {
      obj.storageKeys = [];
    }
    return obj;
  },

  fromPartial(object: DeepPartial<AccessTuple>): AccessTuple {
    const message = { ...baseAccessTuple } as AccessTuple;
    message.address = object.address ?? "";
    message.storageKeys = (object.storageKeys ?? []).map((e) => e);
    return message;
  },
};

const baseTraceConfig: object = {
  tracer: "",
  timeout: "",
  reexec: Long.UZERO,
  disableStack: false,
  disableStorage: false,
  debug: false,
  limit: 0,
  enableMemory: false,
  enableReturnData: false,
  tracerJsonConfig: "",
};

export const TraceConfig = {
  encode(
    message: TraceConfig,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.tracer !== "") {
      writer.uint32(10).string(message.tracer);
    }
    if (message.timeout !== "") {
      writer.uint32(18).string(message.timeout);
    }
    if (!message.reexec.isZero()) {
      writer.uint32(24).uint64(message.reexec);
    }
    if (message.disableStack === true) {
      writer.uint32(40).bool(message.disableStack);
    }
    if (message.disableStorage === true) {
      writer.uint32(48).bool(message.disableStorage);
    }
    if (message.debug === true) {
      writer.uint32(64).bool(message.debug);
    }
    if (message.limit !== 0) {
      writer.uint32(72).int32(message.limit);
    }
    if (message.overrides !== undefined) {
      ChainConfig.encode(message.overrides, writer.uint32(82).fork()).ldelim();
    }
    if (message.enableMemory === true) {
      writer.uint32(88).bool(message.enableMemory);
    }
    if (message.enableReturnData === true) {
      writer.uint32(96).bool(message.enableReturnData);
    }
    if (message.tracerJsonConfig !== "") {
      writer.uint32(106).string(message.tracerJsonConfig);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TraceConfig {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...baseTraceConfig } as TraceConfig;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.tracer = reader.string();
          break;
        case 2:
          message.timeout = reader.string();
          break;
        case 3:
          message.reexec = reader.uint64() as Long;
          break;
        case 5:
          message.disableStack = reader.bool();
          break;
        case 6:
          message.disableStorage = reader.bool();
          break;
        case 8:
          message.debug = reader.bool();
          break;
        case 9:
          message.limit = reader.int32();
          break;
        case 10:
          message.overrides = ChainConfig.decode(reader, reader.uint32());
          break;
        case 11:
          message.enableMemory = reader.bool();
          break;
        case 12:
          message.enableReturnData = reader.bool();
          break;
        case 13:
          message.tracerJsonConfig = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): TraceConfig {
    const message = { ...baseTraceConfig } as TraceConfig;
    message.tracer =
      object.tracer !== undefined && object.tracer !== null
        ? String(object.tracer)
        : "";
    message.timeout =
      object.timeout !== undefined && object.timeout !== null
        ? String(object.timeout)
        : "";
    message.reexec =
      object.reexec !== undefined && object.reexec !== null
        ? Long.fromString(object.reexec)
        : Long.UZERO;
    message.disableStack =
      object.disableStack !== undefined && object.disableStack !== null
        ? Boolean(object.disableStack)
        : false;
    message.disableStorage =
      object.disableStorage !== undefined && object.disableStorage !== null
        ? Boolean(object.disableStorage)
        : false;
    message.debug =
      object.debug !== undefined && object.debug !== null
        ? Boolean(object.debug)
        : false;
    message.limit =
      object.limit !== undefined && object.limit !== null
        ? Number(object.limit)
        : 0;
    message.overrides =
      object.overrides !== undefined && object.overrides !== null
        ? ChainConfig.fromJSON(object.overrides)
        : undefined;
    message.enableMemory =
      object.enableMemory !== undefined && object.enableMemory !== null
        ? Boolean(object.enableMemory)
        : false;
    message.enableReturnData =
      object.enableReturnData !== undefined && object.enableReturnData !== null
        ? Boolean(object.enableReturnData)
        : false;
    message.tracerJsonConfig =
      object.tracerJsonConfig !== undefined && object.tracerJsonConfig !== null
        ? String(object.tracerJsonConfig)
        : "";
    return message;
  },

  toJSON(message: TraceConfig): unknown {
    const obj: any = {};
    message.tracer !== undefined && (obj.tracer = message.tracer);
    message.timeout !== undefined && (obj.timeout = message.timeout);
    message.reexec !== undefined &&
      (obj.reexec = (message.reexec || Long.UZERO).toString());
    message.disableStack !== undefined &&
      (obj.disableStack = message.disableStack);
    message.disableStorage !== undefined &&
      (obj.disableStorage = message.disableStorage);
    message.debug !== undefined && (obj.debug = message.debug);
    message.limit !== undefined && (obj.limit = message.limit);
    message.overrides !== undefined &&
      (obj.overrides = message.overrides
        ? ChainConfig.toJSON(message.overrides)
        : undefined);
    message.enableMemory !== undefined &&
      (obj.enableMemory = message.enableMemory);
    message.enableReturnData !== undefined &&
      (obj.enableReturnData = message.enableReturnData);
    message.tracerJsonConfig !== undefined &&
      (obj.tracerJsonConfig = message.tracerJsonConfig);
    return obj;
  },

  fromPartial(object: DeepPartial<TraceConfig>): TraceConfig {
    const message = { ...baseTraceConfig } as TraceConfig;
    message.tracer = object.tracer ?? "";
    message.timeout = object.timeout ?? "";
    message.reexec =
      object.reexec !== undefined && object.reexec !== null
        ? Long.fromValue(object.reexec)
        : Long.UZERO;
    message.disableStack = object.disableStack ?? false;
    message.disableStorage = object.disableStorage ?? false;
    message.debug = object.debug ?? false;
    message.limit = object.limit ?? 0;
    message.overrides =
      object.overrides !== undefined && object.overrides !== null
        ? ChainConfig.fromPartial(object.overrides)
        : undefined;
    message.enableMemory = object.enableMemory ?? false;
    message.enableReturnData = object.enableReturnData ?? false;
    message.tracerJsonConfig = object.tracerJsonConfig ?? "";
    return message;
  },
};

declare var self: any | undefined;
declare var window: any | undefined;
declare var global: any | undefined;
var globalThis: any = (() => {
  if (typeof globalThis !== "undefined") return globalThis;
  if (typeof self !== "undefined") return self;
  if (typeof window !== "undefined") return window;
  if (typeof global !== "undefined") return global;
  throw "Unable to locate global object";
})();

const atob: (b64: string) => string =
  globalThis.atob ||
  ((b64) => globalThis.Buffer.from(b64, "base64").toString("binary"));
function bytesFromBase64(b64: string): Uint8Array {
  const bin = atob(b64);
  const arr = new Uint8Array(bin.length);
  for (let i = 0; i < bin.length; ++i) {
    arr[i] = bin.charCodeAt(i);
  }
  return arr;
}

const btoa: (bin: string) => string =
  globalThis.btoa ||
  ((bin) => globalThis.Buffer.from(bin, "binary").toString("base64"));
function base64FromBytes(arr: Uint8Array): string {
  const bin: string[] = [];
  for (const byte of arr) {
    bin.push(String.fromCharCode(byte));
  }
  return btoa(bin.join(""));
}

type Builtin =
  | Date
  | Function
  | Uint8Array
  | string
  | number
  | boolean
  | undefined;
export type DeepPartial<T> = T extends Builtin
  ? T
  : T extends Long
  ? string | number | Long
  : T extends Array<infer U>
  ? Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U>
  ? ReadonlyArray<DeepPartial<U>>
  : T extends {}
  ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

if (_m0.util.Long !== Long) {
  _m0.util.Long = Long as any;
  _m0.configure();
}
